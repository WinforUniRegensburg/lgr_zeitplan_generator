%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Hauptteil %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Hauptteil}
\label{chap:Hauptteil}

\section{Grundlegende Überlegungen zur Durchführung des Projektes}
Das Projektseminar „Erstellung eines Zeitplan-Generators für Leichtathletikveranstaltungen“ wird von Thomas Baumer und Benedikt Bruckner, im Folgenden als die Studenten bezeichnet, unter Betreuung von Gerit Wagner durchgeführt. In der Anfangsphase des Projektes stellte sich die Frage wie das Projekt umgesetzt werden soll und welche Software bzw. Programmiersprache zur Problemlösung verwendet werden sollen. 

Für die Wahl einer Skriptsprache wurde zwischen den Möglichkeiten der Verwendung von JavaScript und Python diskutiert. Für beide Sprachen existieren eine Vielzahl an Dokumentationen, Bibliotheken und Tutorials. Beispielsweise kann auf die zur Programmierung benötigte Bibliothek jQuery bei JavaScript zurückgegriffen werden. Da die Studenten bereits erste Erfahrungen in JavaScript sammeln konnten, entschied man sich für JavaScript und sparte sich so eine größere Einarbeitungszeit in eine neue Skriptsprache. Mit der Verwendung von JavaScript können alle gewünschten Ziele erreicht werden.

Des Weiteren wurde die Verwendung einer Versionsverwaltungssoftware diskutiert. Da eine Versionsverwaltung viele Vorteile bietet, wie beispielsweise das Wiederherstellen von alten Zuständen des Projekts und die Protokollierung, wo jede Änderung an den Dateien mit Autor und Datum, also die ganze Versionsgeschichte, nachvollzogen werden kann, entschied man sich auch schnell und eindeutig für die Möglichkeit einer Versionsverwaltung. Außerdem ist es viel leichter, nachvollziehbarer und übersichtlicher als beispielsweise das Verschicken von einzelnen Codeteilen per E-Mail an die anderen Projektteilnehmer. Zudem bietet eine Versionsverwaltung noch die Möglichkeit Zugriffe und Entwicklungszweige zu koordinieren, was jedoch bei diesem Projekt aufgrund der Komplexität hinsichtlich der Projektteilnehmer nicht zwingend notwendig ist.\protect{\footnote{Skript des Kurses  Praxis des Programmierens SS16: Versionsverwaltung Folien 29ff.}}
Als Versionsverwaltungssoftware einigte man sich schließlich auf GitHub mit der \ac{GUI} des „GitHub Desktops“.  

Als Editor zur Erstellung von HTML- bzw. JavaScript-Code wurde einerseits unter Windows Notepad++ und andererseits für Mac OS die Software Brackets verwendet, da diese Open Source-Editoren sind und viele Sprachen, wie beispielsweise JavaScript und HTML unterstützen. Sie genügen also allen im Projekt erwartenden Ansprüchen.
Bei der Entwicklung wurde vordergründig der Browser Google Chrome verwendet, da dieser alle verwendeten Sprachen, Frameworks und Methoden unterstützt. Darüber hinaus wurden auch die Browser Safari, Firefox und Opera für Tests miteinbezogen.

Ein weiteres Ziel ist eine fertige Desktop-App zu entwickeln. Dafür macht man sich die Software node.js in Verbindung mit dem Framework Electron zunutze. Dies bietet den großen Vorteil, dass man unabhängig vom Browser ist und beispielsweise im JavaScript-Code sich für die jeweiligen Browser umständliche Anpassungen spart. Ein weiteres Argument ist, dass nach dem Erstellen des eigentlichen Programms mit dem Editor nur noch kleine Anpassungen vorgenommen werden müssen, um ein fertiges Programm zu erhalten. Dies hat die positive Auswirkung, dass der Nutzer nicht extra die verschiedenen HTML-Dateien abspeichern muss, womit er sich möglicherweise auch nicht sehr gut auskennt. Ein eigenständiges Programm erleichtert die Bedienbarkeit und die Nutzerfreundlichkeit. 

Abgesehen von der Funktionalität soll das Zeitplan-Tool auch eine ansprechende Oberfläche besitzen. Dies erhöht die Benutzerfreundlichkeit und lässt den Zeitplan bzw. die Veranstaltung auch besser erscheinen. Da der Zeitplan auch für große Leichtathletikveranstaltungen verwendet werden soll, ist die Oberflächengestaltung für die Wahrnehmung der Veranstaltung mitentscheidend. Der Nutzer erwartet eine klare und optisch ansprechende Darstellung. Um auch ein klares Design für den Zeitplan zu entwickeln, verwendet man das beliebte \ac{CSS}-Framework Bootstrap. Bootstrap bietet eine große Menge an Gestaltungsvorlagen für Oberflächengestaltungselemente, wie beispielsweise für Buttons oder Formulare. Diese ermöglichen eine einfache und schnelle Umsetzung eines ansprechenden Designs für das Zeitplan-Tool.\protect{\footnote{\url{https://de.wikipedia.org/wiki/Bootstrap_(Framework), abgerufen am 30.11.16}} Der Entwickler benötigt also nur ein Basiswissen in HTML und CSS, um mit Bootstrap zu arbeiten. Ein weiterer großer Vorteil ist, dass Bootstrap mit allen gängigen Browsern kompatibel ist. Zudem wird eine angepasste Darstellung auf mobilen Engeräten unterstützt.\protect{\footnote{\url{http://www.w3schools.com/bootstrap/bootstrap_get_started.asp}
, abgerufen am 30.11.16}}

Darüber hinaus diskutierte man zu diesem frühen Stadium des Projektes bereits wie die abschließende Projektseminararbeit geschrieben werden soll. Betreuer Gerit Wagner empfahl die Verwendung des Softwarepaketes LaTex, das bei der Erstellung von größeren Abschlussarbeiten viele Vorteile gegenüber Microsoft Office Word bietet, abgesehen von dem Nachteil der Einarbeitungszeit in die neue Umgebung. Ein Argument ist, dass LaTex die Formatierung und den Inhalt voneinander trennt, indem man zu verändernde Textstellen mit Befehlen in einem Editor kennzeichnet, was ein sauberes und genau festlegbares Layout zur Folge hat.\protect{\footnote{\url{https://de.wikipedia.org/wiki/LaTeX}, abgerufen am 21.11.16}}  Außerdem gibt es seitens des Lehrstuhls bereits eine LaTex-Vorlage für Projektseminararbeiten auf die zurückgegriffen werden kann. Somit können die strengen Anforderungen für die Formatierung bzw. Gestaltung einer umfangreichen Projektseminarabschlussarbeit durch ein sauberes Layout erzielt werden. Zudem gibt es bereits grafische Editoren die den Umgang mit LaTex vereinfachen. Im Rahmen des Projekts wurde die Software TeXworks verwendet. Des Weiteren kann man LaTex-Dokumente mit Hilfe von Git versionieren und so wieder alle Vorteile einer Versionsverwaltung nutzen.

Nachdem alle für die Problemlösung benötigten Programme, Frameworks und Skriptsprachen festgelegt wurden, wird im Folgenden die Vorgehensweise zur Durchführung des Projektes beschrieben.

\section{Konzeptionelle Phase und Identifikation möglicher Probleme bzw. Schlüsselstellen
}
Dieser Unterpunkt soll einen Überblick über die allgemeine Vorgehensweise geben, die später noch detaillierter erläutert wird. Nach ersten Überlegungen mit welchen Mitteln das Projekt umgesetzt werden soll, folgten viele Gedanken über mögliche Schwierigkeiten bzw. die Herangehensweise bei der Erstellung des Zeitplan-Generators. Zuerst wurde natürlich die Ursprungsdatei genauer analysiert. Es wurde festgestellt, dass die Ursprungsdatei sehr viele irrelevante Daten beinhaltet und man jeweils nur die zwei Absätze über den Teilnehmerlisten benötigt. Parallel dazu verglich man die Zusammensetzung der Daten mit den dafür vorgesehenen Positionen in der Ergebnistabelle. Als Referenz für die Ergebnistabelle wurde wieder der Zeitplan der Sparkassen Gala 2016 verwendet. Es stellte sich heraus, dass das Auslesen der relevanten Daten eine Schwierigkeit werden könnte, da die Datensätze teilweise unterschiedliche Strukturen haben und die Informationen oft anhand mehrerer Suchkriterien identifiziert werden müssen. Des Weiteren wurde deutlich, dass die Befüllung der Tabelle eine Herausforderung werden kann, da die Wettkämpfe anhand des Datums, der Uhrzeit und der Teilnehmerklasse zugeordnet werden müssen. Bei der Umsetzung muss also ein besonderes Augenmerk auf die Identifikation der relevanten Daten und die saubere bzw. dynamische Befüllung der Ergebnistabelle gelegt werden. 

Ausgehend der gemeinsamen Überlegungen im Team wurden fünf größere Schritte für die Problemlösung bzw. Erstellung des Zeitplan-Generators definiert: Der erste Schritt ist die Spezifikation des Rohtextes. In diesem Prozess wird die genau Form des Inputfiles festgehalten, was insbesondere den Inhalt und die Struktur beinhaltet. Dabei ist es von besonderer Wichtigkeit zu erkennen an welchen Positionen die wesentlichen Daten, wie Datum, Uhrzeit, Teilnehmerklasse und Wettkampfbezeichnung stehen. Der darauffolgende Schritt ist das Einlesen der Ursprungsdatei. Um mit dem Rohtext zu arbeiten muss dieser natürlich zuerst vom Programm identifiziert und eingelesen werden. Hier ist es die Aufgabe des Nutzers die gewünschte Datei, die die zuvor spezifizierte Form aufweist, auszuwählen. Der dritte Schritt ist, dass man aus der Ursprungsdatei nur die relevanten Daten herausfiltert. Hier sollen praktisch nur noch alle relevanten Absätze betrachtet werden. Anschließend müssen diese Daten im vierten Schritt gesäubert werden. Das bedeutet, dass anhand bestimmter Suchkriterien das Datum, die Uhrzeit, die Teilnehmerklassen und die Wettkampfbezeichnung erkannt und strukturiert abgelegt werden. Im letzten Schritt wird schließlich der gewünschte Zeitplan aus den zuvor identifizierten Informationen dynamisch generiert. Für jeden Wettkampftag soll dabei eine eigene Tabelle erzeugt werden. Als Überschrift für eine Tabelle dient das Datum mit dem zugehörigen Wochentag. Der Beginn der Veranstaltung steht in der ersten Spalte unter dem Titel Zeit, wobei aufsteigend nach der Uhrzeit sortiert wird; die Altersklassen werden in der ersten Zeile ab der zweiten Zelle angeführt, wobei diese aszendierend und nach dem Geschlecht sortiert dargestellt werden und die Wettkampfbezeichnung wird schließlich in der richtigen Zelle ausgehend von Datum, Uhrzeit und Altersklasse eingetragen. 
Zusammenfassend werden also neben dem vorhandenen Inputfile vier HTML-Files mit JavaScript erstellt, die der Problemlösung dienen. Dies hat den Vorteil der Modularität der unterschiedlichen Funktionen und des weiteren ist es bei der Programmierung leichter umzusetzen. Zudem ist eine gute Testbarkeit der Funktionalität bzw. eine einfachere Wartung  und Debugging ermöglicht. Die genaue Vorgehensweise in den einzelnen Schritten wird nun im Folgenden genauer erläutert.

\section{Spezifikation des Rohtextes}
Die erste Anforderung an den Rohtext ist, dass dieser das Dateiformat HTML besitzen soll. Dies ermöglicht eine genaue Navigation mit jQuery. Im Folgenden wird nun der Inhalt und die Struktur des Eingangsfiles näher spezifiziert. Grundsätzlich kann der Rohtext beliebigen HTML-Code beinhalten mit der Ausnahme des im später erläuterten Aufbau eines Paragraphen. 
Das für die Entwicklung verwendete Ursprungsfile weist beispielsweise folgenden Aufbau auf. In den ersten zwei Zeilen des Files steht die Überschrift („Laufnacht und Sparkassen Gala 2016“) und der Ort bzw. das Datum („Regensburg, von 04.06.2016-05.06.2016“) geschrieben. Daraufhin folgen verschiedene Verweise, wie die Altersklassen (z.B. „Männer“ und „weibliche Jugend U20“) und alle Wettkampfbezeichnungen (z.B. „100m (Vorprogramm) - Zeitläufe“). Im Anschluss kommen die relevanten Zeilen für die Erstellung des Zeitplanes.\\
Im Testfile beispielsweise:\\
\begin{tabular}{lcr}
Zeile 1: & „100m (Vorprogramm), Frauen + U20 + U18 – Zeitläufe“ \\
Zeile 2: & „Datum: 05.05.2016 Beginn: 12:00“ \\
\end{tabular} \\
Diese zwei Zeilen sind DOM-Elemente der Form <p class=“ev1“>...</p>. Es handelt sich hier also um Paragraphen und man kann alle relevanten Daten mit Hilfe dieser Form identifizieren.
Der Paragraph ist im Allgemeinen also folgendermaßen aufgebaut:
Zeile 1 beinhaltet die Teilnehmerklassen (z.B. „Frauen + U20 + U18“) ungefähr in der Mitte der Zeile. im String gekennzeichnet folgt auf die ersten Zeichen und ein Komma (xxxx,) die Teilnehmerklasse. Auf die Teilnehmerklasse folgt ein Bindestrich und die nachfolgenden Zeichen (-xxxx). Die Teilnehmerklassen werden also initiiert durch ein Komma und beendet durch einen Bindestrich. Zudem enthalten alle Teilnehmerklassen die Zeichenfolgen „weiblich“, „weibliche“ oder „Frauen“ bzw. „männlich“, „männliche“ oder „Männer“. Außerdem ist es möglich, dass in diesem Abschnitt mehrere Teilnehmerklassen, abgetrennt durch ein „+“, enthalten sind. Auf das Pluszeichen würden dann ein „U“ und zwei Zahlen folgen. Ein weiterer Bestandteil der ersten Zeile ist gegebenenfalls der Inhalt der runden Klammern. Dort befinden sich Zusatzinformationen, die entfernt werden, wenn es sich um „Hauptprogramm“, „Gala“, „Vorprogramm“ oder „Laufnacht“ handeln sollte. Ansonsten bleibt der Inhalt der Klammern an dieser Stelle stehen. Es gibt aber auch den Fall, dass keine Zusatzinformationen in runden Klammern enthalten sind. Den Rest der Zeichenkette (nach Entfernung der Teilnehmerklasse und gegebenenfalls der Klammern) bildet die Disziplin. Die Disziplin setzt sich also aus den ersten Zeichen bis zur Klammer und den letzten Zeichen nach dem Bindestrich zusammen. Im Beispiel entsteht die Disziplin „100m Zeitläufe“.
Die zweite Zeile enthält das Datum und die Uhrzeit. Der erste Eintrag in der zweiten Zeile ist „Datum“ gefolgt vom Datum selbst in der Form dd.mm.yyyy. Der zweite Eintrag in der zweiten Zeile ist „Beginn“ gefolgt von der Uhrzeit des Wettkampfstarts mit dem vierundzwanzig Studenformat hh:mm.

Abgesehen davon kommt nach den Paragraphen in der verwendeten Ursprungsdatei immer eine Tabelle mit der Startnummer, dem Namen, dem Jahrgang, der Nationalität, dem Verein, der Saisonbestleistung und der persönlichen Bestleistung, sowie den verschiedenen Einträgen der Wettkampfteilnehmer. Dies ist jedoch für die Zeitplangenerierung nicht weiter relevant.

Zusammenfassend muss das Ausgangsfile also im HTML-Format vorliegen und DOM-Elemente mit der Form <p class= „ev1“>...</p> enthalten, die als Inhalt die relevanten Daten haben. Zudem müssen die Paragraphen den wie oben beschriebenen Aufbau aufweisen, damit alle Daten im Anschluss richtig verarbeitet werden können. 
Nachdem der Rohtext genauer spezifiziert wurde, wird die Funktionsweise des File-Uploaders im Folgenden genauer erklärt.

\section{Funktionalität des File-Uploaders}
Nachdem das Inputfile genauer spezifiziert wurde, wird nun die Funktionsweise des File-Uploaders näher erklärt. Die Vorbedingung für den File-Uploader ist, dass der Rohtext in der zuvor definierten Form vorliegt.

Im ersten Schritt wird nun der HTML-Code erläutert. Dieser setzt sich aus dem HTML-Kopf (HEAD) und dem HTML-Körper (BODY) zusammen, die jeweils auch durch die gleichnamigen Tags eingeleitet und beendet werden. Da der File-Uploader ein Teil der Benutzeroberfläche ist, soll diese auch ansprechend mit Bootstrap bzw. CSS gestaltet werden. Zu Beginn des HEADs müssen für die Verwendung von Bootstrap drei Meta-Tags (<meta />) deklariert werden. 
Dabei gibt das erste Meta-Tag den zu verwendenden Zeichensatz \ac{UTF-8} an. Die Verwendung von UTF-8 als Zeichensatz hat den Vorteil, dass alle Zeichen (auch Fremdwörter und Sonderzeichen) beliebig verwendet werden können.\protect{\footnote{\url{https://wiki.selfhtml.org/wiki/Zeichenkodierung}, aberufen am 23.11.16}} Des weiteren ist UTF-8 beispielsweise von der \ac{IETF} und der \ac{ISO} als Norm definiert worden, was die Nutzung begünstigt.\protect{\footnote{\url{https://de.wikipedia.org/wiki/UTF-8}, abgerufen am 23.11.16}} 
Das zweite Meta-Tag muss ebenfalls standardmäßig definiert werden, da so eine bestmögliche Darstellung im Internet Explorer, auch in den älteren Versionen, gewährleistet werden kann.\protect{\footnote{\url{http://v4-alpha.getbootstrap.com/getting-started/browsers-devices/ }, aberufen am 02.12.16}} 
Die Metainformation mit dem Namen viewport stellt sicher, dass die Website auch auf mobilen Geräten richtig dargestellt wird. Dies ist ein sehr wichtiger Faktor, da heutzutage eine Vielzahl der Nutzer den mobilen Browser auf einem Smartphone verwenden und sich auf diesem Weg den Zeitplan anschauen wollen. Durch den Ausdruck width=device-width wird eine genaue Anpassung der Website an die Bildschirmgröße des mobile Endgeräts sicher gestellt. Des weiteren wurde hier die Möglichkeit des Zoomens nicht ausgeschlossen, da die Darstellung des Zeitplans auf einem mobilen Endgerät eventuell relativ klein ausfällt und der Nutzer die Informationen nur schwer erkennen kann. Das Zoom-Level wird beim ersten Laden der Website (initial-scale) mit dem Browser auf 1 gesetzt.\protect{\footnote{\url{http://www.w3schools.com/bootstrap/bootstrap_get_started.asp}, abgerufen am 02.12.16}} 
Im Anschluss wurde im HEAD noch der Titel des Web-Dokuments und zur Einbindung von Bootstrap die verwendete (minimierte) Bootstrap-CSS-Version definiert. 

Im BODY wird zunächst die Überschrift ("page-header") festgelegt. Die Überschrift soll dabei separat, durch eine horizontale Linie unter der Überschrift, von den anderen Inhalten des File-Uploaders dargestellt werden. Dies wurde mit dem div-Element in Verbindung mit der Klasse .page-header realisiert. Die Überschrift soll der Nutzerhinweis „Bitte die Teilnehmerliste einlesen“ sein.\protect{\footnote{\url{http://www.w3schools.com/bootstrap/bootstrap_jumbotron_header.asp}, abgerufen am 02.12.16}}  
Neben der Überschrift muss im File-Uploader noch ein Button plaziert werden, wo der User das gewünschte File auswählen kann. Da der Button mit der zentrale Bestandteil dieses Web-Dokuments ist, entschied man sich zuerst einen gesonderten grauen Bereich unterhalb der Trennlinie zur Überschrift zu definieren, wo später der Button plaziert werden soll. Dies wurde mit der Bootstrap Wells-Klasse umgesetzt, die um ein Element einen grauen Bereich legt.\protect{\footnote{\url{http://www.w3schools.com/Bootstrap/bootstrap_wells.asp}, abgerufen am 02.12.16}} 
Für die Darstellung des Buttons selbst entschied man sich für ein Design, das an die verwendeten Farben der LG Telis Finanz-Website angelehnt sein soll. Dies soll eine konsistente Darstellung bei diesen Leichtathletikveranstaltungen unterstreichen. Bei den verschiedenen Button Styles von Bootstrap wählte man deshalb den Info-Button (.btn-info), der hellblau gefüllt ist und einen weißen Schriftzug hat. Der Schriftzug des Buttons soll der Nutzerhinweis „Datei hochladen“ sein. Außerdem enthält der Button noch die Funktion auf einen Click zu reagieren. Die ausgelöste Methode clickedButton() wird im JavaScript-Teil definiert. Sie bewirkt, dass nach dem Click auf den Button der Click auf das Inputfile ausgeführt wird, das zuvor unsichtbar bzw. versteckt war.
Außerdem wurde im BODY noch der Input bestimmt, der vom Typ eines Files sein soll. Der Input wird am Anfang auf versteckt (style="display: none") gesetzt, da er erst angezeigt werden soll, wenn über den Button eine Datei ausgewählt wurde (click). 
Darüber hinaus wurde die Möglichkeit für den Nutzer das File mit Hilfe eines Formulars auszuwählen integriert (form-Tag). Formulare in HTML dienen der Eingabe von Informationen durch den Benutzer. Zudem wurde im HTML-Körper noch die Bildschirmausgabe (displayArea) deklariert, die eventuelle Ausgaben anzeigt. 
Am Ende des BODYs wurden noch die Skripte, die für Bootstrap benötigt werden deklariert. Diese sind jQuery, das für Bootstrap JavaScript-Plugins benötigt wird, und das kompilierte JavaScript.\protect{\footnote{\url{http://holdirbootstrap.de/los-gehts/}, abgerufen am 02.12.16}}  

Im JavaScript-Code wurden die restlichen Funktionalitäten des File-Uploaders festgelegt. JavaScript ist eine Skriptsprache, die HTML um Funktionalitäten erweitert und dynamische Informationen im Web realisiert. Das Skript wird in HTML-Dokumente mit dem script-Tag eingebettet. Dies ermöglicht beispielsweise, dass Benutzerinteraktionen ausgewertet bzw. Inhalte erzeugt oder verändert werden können. Diese Eigenschaften werden hier benötigt. 
Es wurden zuerst Variablen definiert, die die relevanten DOM-Elemente „fileInput“ und „displayArea“ abspeichern, um diese im JavaScript-Code verändern zu können bzw. um auf diese zugreifen zu können. 
Im Folgenden wurde der User-Input als Event definiert. Dies ermöglicht, dass man auf eine Dateiauswahl des Nutzers im Select-Auswahlmenü reagieren kann. Hat der Nutzer also eine Auswahl getroffen bzw. liegt eine Veränderung beim Inputfile vor (change), wird das Event ausgelöst. Bei der Auslösung des Events müssen zunächst einige grundlegenden Dinge zur Ausführung des JavaScript-Codes festgelegt werden. 
Der Code arbeitet mit dem zuerst ausgewählten File (erste Stelle im Array) und prüft anschließend, ob das File den zuvor definierte Typ HTML aufweist. Wird an dieser Stelle erkannt, dass ein anderes Format vorliegt, wird das Event abgebrochen und es wird dem Nutzer eine Fehlermeldung („File not supported!“) im displayArea ausgegeben. 
Handelt es sich um ein HTML-File, ermöglicht die File Reader-\ac{API} das Auslesen des Textes. Hier wird zur Fehlervermeidung eine Verwendung eines falschen Texttyps vermieden. Um einen korrekten deutschen Text als Ergebnis zu erhalten, muss das File nach ISO-8859-1 enkodiert werden. Dies vermeidet beispielsweise, dass im Web-Dokument Umlaute nicht richtig dargestellt werden können. Sobald das File fertig geladen ist, wird der Inhalt des Eingangsfiles in der Variable „rawText“ gespeichert. Hier macht man sich die Methoden onload und result der File Reader-API zunutze. Onload erkennt, wann das File komplett eingelesen wurde und result gibt den Inhalt des Files zurück.\protect{\footnote{\url{https://www.w3.org/TR/FileAPI/}, abgerufen am 24.11.16}} Darüber hinaus soll das Ergebnis des Einlesens, also die zuvor definierte Variable rawText, im sessionStorage abgespeichert werden. Die Datenspeicherung wird also an die aktuelle Browsersession gebunden, d.h. die Daten bleiben deshalb auch nur so lange gespeichert bis die Sitzung geschlossen wurde. Dies ermöglicht auch ein einfacheres Debuggen, da beispielsweise die fertige Tabelle selbst noch auf den Rohtext zugreifen könnte. Dies ist ein großer Vorteil gegenüber dem Versenden der Daten mit dem form-Tag. Zudem können andere Fenster im Browser die Daten während der Sitzung nutzen. Nachdem dies geschehen ist wird der Text aus dem sessionStorage angezeigt. Diese beiden Funktionalitäten wurden in den Methoden showText(area) bzw. saveRawText(rawText) ausgelagert. 

 Nach dem Abschluss der Programmierphase bzw. des Testens wurde der Submit-Button und die Anzeige des eingelesenen und abgespeicherten Files im Code auskommentiert bzw. auf versteckt (hidden) gesetzt. Dies hat den Vorteil, dass man bei der Ausführung des kompletten Codes zur Erstellung der Tabelle durch das automatische Weiterleiten zum ParagraphHandler Zeit spart. Zudem ist es für den Nutzer irrelevant, dass er das eingelesene File mit den unstrukturierten Daten angezeigt bekommt. Bei Bedarf kann das Auskommentieren natürlich wieder rückgängig gemacht werden, was das Debugging bzw. die Erweiterung des Tools vereinfachen würde. 

Ist also der Rohtext (rawText) im sessionStorage, leitet das Programm automatisch (Auto-Submit) zum nächsten Schritt bei der Generierung einer Tabelle, dem ParagraphHandler, weiter. Beim Prozess der Erstellung der Ergebnistabelle wird im Folgenden die Funktionsweise des ParagraphHandlers detaillierter erklärt.

\section{Paragraph Handler: Herausfiltern der Paragraphen aus dem Rohtext}

In diesem Schritt ist es das Ziel aus dem im sessionStorage gespeicherten Rohtext die Paragraphen, die für die Zeitplanerstellung benötigt werden, zu erhalten. Darüber hinaus sollen die Paragraphen gleich unterteilt nach erster und zweiter Zeile in einem Array abgespeichert werden.

Dabei wurden zunächst im HEAD der Titel des HTML-Dokuments („Paragraph Handler!“) und im BODY die Weiterleitung zum HTML-Dokument „Cleaner“ deklariert. Zudem wurden in der Implementierungsphase auch wieder ein Submit-Button und ein displayArea definiert, um die Funktionalität zu testen bzw. Fehler zu beheben. Im Anschluss wurden die verwendeten Skripte definiert. Da man nun alle DOM-Elemente der Form eines Paragraphen (<p class=„ev1“>...</p>) aus der im sessionStorage abgespeicherten Ursprungsdatei herausfiltern will, wird bei der Programmierung das Framework jQuery verwendet. jQuery bietet unter anderem den Vorteil, dass es eine einfache und schnelle Möglichkeit bietet DOM-Elemente mit CSS-artigen Selektoren auszuwählen und zu bearbeiten. jQuery ermöglicht also DOM-Abfragen mit einer einfachen Syntax und bietet zudem Methoden, die wichtige Aufgaben mit sehr wenig Code erledigen.\protect{\footnote{JavaScript und jQuery - Interaktive Websites entwickeln, von Jon Duckett S.294ff}} Bei der Einbindung von jQuery in den Paragraph Handler hat man sich bei der Angabe der Quelle (src) für die aktuellste jQuery-Version als Link entschieden. Dies hat den Vorteil, dass man jQuery nicht erst runterladen muss und den lokalen Pfad als Quelle angeben muss. Des weiteren wird so gewährleistet, dass immer die aktuellste jQuery-Version verwendet wird.\protect{\footnote{\url{http://www.html-seminar.de/jquery-tutorial.htm}, abgerufen am 27.11.16}} Darüber hinaus muss jQuery als Skript für Electron und Node.js angegeben werden. 

Die eigentliche Funktionalität des Paragraph Handlers wird im JavaScript-Code umgesetzt. Um mit der Ursprungsdatei arbeiten zu können, muss diese zunächst aus dem sessionStorage geladen werden. Dies geschieht in der Methode getRawText(). Anschließend wird der rawText im sessionStorage gespeichert, was in der Methode saveParagraphText(paragraphText) umgesetzt ist. Nach dem Speichern soll der Rohtext angezeigt werden, damit man mit jQuery diesen durchlaufen und die Tags erkennen bzw. finden kann. jQuery soll jetzt alle Paragraphen mit der Klasse „ev1“ finden und diese in der Variable „\$html“ speichern. Mit dem Ausdruck „\$('p.ev1')“ werden nun alle Elemente mit dieser Eigenschaft zurückgegeben. Anschießend werden die Elemente in der jQuery-Auswahl mit der Methode clone() kopiert.\protect{\footnote{\url{http://www.w3schools.com/jquery/html_clone.asp}, abgerufen am 27.11.16}} Die Methode text() gibt nur den Textinhalt ohne Tags zurück. Nachdem die relevanten Informationen in der Variable \$html gespeichert wurden, kann der Inhalt der Seite bzw. der angezeigte Rohtext aus dem displayArea gelöscht werden. Dies wird durch das Setzen eines leeren Strings mit Hilfe der Eigenschaft innerHTML, die den Inhalt eines HTML-Elements speichert, realisiert.\protect{\footnote{\url{https://wiki.selfhtml.org/wiki/JavaScript/DOM/Element/innerHTML}, abgerufen am 27.11.16}} Anschließend soll der Textinhalt der Paragraphen mit der Klasse ev1 der neue Inhalt der Seite sein. Dies wird mit der jQuery-Methode prepend(prepended text) ermöglicht, die den Inhalt (\$html) am Beginn der selektierten Elemente (pre) einfügt.\protect{\footnote{\url{http://www.w3schools.com/jquery/html_prepend.asp}, abgerufen am 27.11.16}} Da nun der Textinhalt der Paragraphen im displayArea angezeigt wird, kann der Inhalt nun mit der saveParagraphText(paragraphText)-Methode im sessionStorage abgespeichert werden.

Im nächsten Schritt im Paragraph Handler sollen die Paragraphen noch strukturiert nach erster und zweiter Zeile als Array abgespeichert werden. Dies erleichtert das weitere Vorgehen bei der Generierung des Zeitplans. Dafür wurde zunächst ein Konstruktor für einen strukturierten Paragraphen (StrucParagraph(firstLine, secondLine)) deklariert, wo die Paragraphen abgelegt werden können. Die Verwendung eines Konstruktors ermöglicht eine bessere und klare Verwendung im Code. Um ein Array aus Paragraph-Objekten (StrucParagraph) zu speichern, benötigt man zuerst den im sessionStorage gespeicherten unstrukturierten Textinhalt der Paragraphen. Mit dem Aufruf „sessionStorage.getItem('paragraphText')“ werden die Daten aus dem sessionStorage abgefragt und in der Variable „text“ gespeichert. Des weiteren muss das Array selbst definiert werden. Zudem werden drei Variablen deklariert, die die Anfangs-, Mittel- bzw. Endposition des Paragraphen sein sollen. Diese Variablen sollen bei der Aufteilung des Textes in die zwei Zeilen helfen. Bei der Initialisierung werden das Array und die Variablen zunächst auf leer bzw. 0 gesetzt. Darüber hinaus wurde die Variable „patternTimeLength“ angelegt, die die Zeichenlänge der Uhrzeit angeben soll. Da sich die Uhrzeit immer aus zwei Stellen Stundenanzeige, einem Doppelpunkt und zwei Stellen Minutenanzeige zusammensetzt, ergibt sich in Summe eine Zeichenlänge von fünf. Deshalb wurde die Variable bei der Initialiserung auf fünf gesetzt.

Um den ganzen Text aus dem sessionStorage zu durchlaufen, benötigt man eine while-Schleife, die solange läuft, bis alle Daten erfasst und im Array abgespeichert wurden. Dabei soll die Schleife genau einmal für jeden Paragraphen durchlaufen werden. Es muss also zuerst ein Kriterium herausgefunden werden, um das Ende eines Paragraphen zu bestimmen. Da die Uhrzeit immer an letzter Stelle in den Paragraphen steht, wird die Position nach der Uhrzeit als Ende des aktuell betrachteten Paragraphen festgelegt. Nun muss eine Möglichkeit gefunden werden, damit das Programm diese Stelle finden kann. Da die Startzeit immer fünf Zeichen hat und immer durch das Stichwort „Beginn:“ eingeleitet wird, könnte man nach dem Stichwort suchen und die restlichen Zeichen aufaddieren, um die gewünschte Position zu erhalten. Eine weitere Möglichkeit ist, dass man die Position der Uhrzeit mit Hilfe eines regulären Ausdrucks identifiziert. Dies hat den Vorteil, dass auch wirklich sichergestellt werden kann, dass eine valide Uhrzeit im Paragraphen gefunden wird. Der reguläre Ausdruck schreibt die Form vor, die die Uhrzeit aufweisen soll. Der gesamte reguläre Ausdruck setzt sich folgendermaßen zusammen:  
\begin{verbatim}
([01]\d|2[0-3]):[0-5]\d
\end{verbatim}
Die Uhrzeit soll mit einer 0 oder 1 gefolgt von einer Zahl (0-9), im regulären Ausdruck als d für digit dargestellt, bzw. mit einer 2 gefolgt von den Zahlen 0, 1, 2, oder 3 beginnen. Dies soll die Stunden der Uhrzeit widerspiegeln. Nach den Stunden soll in der Uhrzeit der Doppelpunkt enthalten sein. Da die Minutenanzeige höchstens 59 anzeigen kann, erlaubt der reguläre Ausdruck an der ersten Stelle der Minutenanzeige nur eine Zahl zwischen 0 und 5. Die letzte Stelle der Uhrzeit darf eine Zahl zwischen 0 und 9 sein (digit). 

Um im Paragraphen den Mittel- und Endpunkt zu finden und zu erhalten, verwendete man die search- bzw. slice-Methode. Alternativ wäre hier auch die Verwendung von jQuery möglich gewesen. Diese Methoden ermöglichen aber ein schnelles und einfaches Erhalten der gewünschten Positionen im Paragraphen, weshalb man sich für die Verwendung dieser Methoden im Code entschied.
Mit Hilfe der Methode search wird nun nach der im regulären Ausdruck definierten Form im Text gesucht und die Position der Übereinstimmung zurückgegeben.\protect{\footnote{\url{http://www.w3schools.com/jsref/jsref_search.asp}, abgerufen am 27.11.16}} Da die Position vor der Position der Uhrzeit geliefert wird muss nun noch die patternTimeLength dazu addiert werden, um das Ende eines Paragraphen zu erhalten. Diese Position wird dann in der Variable endSliceP abgespeichert. Mit Hilfe dieser Variable kann also genau erkannt werden, wann der Paragraph endet. Der Paragraph wird nun mit Hilfe der slice-Methode aus dem ganzen Text abgeschnitten und in die Variable storageOneParagraph geschrieben. Dabei braucht die slice-Methode als Parameterwerte einen Start- und Endpunkt, wobei der Endpunkt nicht mehr Teil des Ergebnisstrings ist.\protect{\footnote{\url{http://www.w3schools.com/jsref/jsref_slice_array.asp}, abgerufen am 27.11.16}} 

Um die Paragraphen nun in die zwei Zeilen zu unterteilen muss das Ende der ersten Zeile bzw. der Anfang der zweiten Zeile erkannt werden. Als Kriterium wurde hier das Stichwort „Datum“ gewählt, da dies bei jedem Paragraphen am Anfang der zweiten Zeile enthalten ist und nicht Bestandteil der ersten Zeile ist. Um das Stichwort „Datum“ im Paragraphen zu finden nutzt man wieder die search-Methode, die die Position des Wortes zurückgibt. Die Position wird in der Variable middleSliceLine (Mittelstück des Paragraphen) gespeichert. Für die Aufteilung des Paragraphen an dieser Stelle nutzt man wieder die slice-Methode. Die erste Zeile geht von der Stelle 0 (Anfangsposition des Paragraphen bzw. startSliceP) des Paragraphen bis zur middleSliceLine-1. Hier muss man die eine Position noch abziehen um von der Stelle des Datums in die erste Zeile zu kommen. Die zweite Zeile hat als Startpunkt die middleSliceLine und als Endpunkt die endSliceP. Die entstandenen Strings für die erste und zweite Zeile speichert man dabei gleich in den Variablen storageFirstLine bzw. storageSecondLine ab. Im Anschluss muss man nun noch die beiden Zeilen in einen StrucParagraph umwandeln und diesen zum Array hinzufügen, was mit der push-Methode umgesetzt wird. Im Array wird also der Paragraph in der Form wie er angezeigt wurde zwischengespeichert. Jetzt wird mit dem Aufruf text=text.slice(endSliceP) noch sichergestellt, dass der bereits abgearbeitete Paragraph aus dem Text weggeschnitten wird und im nächsten Durchlauf der darauffolgende Paragraph betrachtet wird.

Diese Anweisungen werden solange für jeden Paragraphen durchlaufen, bis alle Paragraphen mit der gewünschten Unterteilung in erster und zweiter Zeile zum Array hinzugefügt wurden.

Im letzten Schritt müssen die Paragraphen bzw. das Array noch gespeichert werden. Das Array wird als \ac{JSON} im sessionStorage abgespeichert, um Daten zwischen den HTML-Dokumenten austauschen zu können. JSON hat den Vorteil, dass das Format kompakter ist als HTML/XML.\protect{\footnote{JavaScript und jQuery - Interaktive Websites entwickeln, von Jon Duckett S.374}} Zudem ermöglicht die Methode stringify(value) ein simples Parsen zu einem String. Das Array wird also als String in der Variable arrayJSON abgespeichert. 

Nachdem das Ziel die relevanten Daten aus der Ursprungsdatei zu erhalten und die Unterteilung des Paragraphen in erste und zweite Zeile erledigt wurden, müssen die Veranstaltungsdaten im folgenden Schritt extrahiert werden. Dies wird in dem HTML-Dokument „Cleaner“ umgesetzt. Wie beim File Uploader wurde nach der Implementierungsphase das Anzeigen des Textes im displayArea bzw. der Submit-Button, um zum nächsten HTML-Dokument zu kommen auskommentiert. Es wurde wieder ein automatischer Submit integriert, der zum nächsten HTML-Dokument weiterleitet.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
