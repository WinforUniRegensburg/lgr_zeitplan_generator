%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Hauptteil %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Hauptteil}
\label{chap:Hauptteil}

\section{Grundlegende Überlegungen zur Durchführung des Projektes}
Das Projektseminar „Erstellung eines Zeitplan-Generators für Leichtathletikveranstaltungen“ wird von Thomas Baumer und Benedikt Bruckner (beide 5. Semester Wirtschaftsinformatik) unter Betreuung von Gerit Wagner durchgeführt. In der Anfangsphase des Projektes stellte sich die Frage wie das Projekt umgesetzt werden soll und welche Software bzw. Programmiersprache zur Problemlösung verwendet werden sollen. 

Für die Wahl einer Programmiersprache wurde zwischen den Möglichkeiten der Verwendung von JavaScript und Python diskutiert. Für beide Sprachen existieren eine Vielzahl an Dokumentationen, Bibliotheken und Tutorials. Beispielsweise kann auf die zur Programmierung benötigte Bibliothek jQuery zurückgegriffen werden. Zudem wird ein klares und übersichtliches Programmieren sowohl bei JavaScript, als auch bei Python ermöglicht. Da Thomas Baumer und Benedikt Bruckner aber bereits im Kurs „Internettechnologien und Network-Computing“ erste Erfahrungen in JavaScript sammeln konnten, entschied man sich für JavaScript und sparte sich so eine größere Einarbeitungszeit in eine neue Programmiersprache. Mit der Verwendung von JavaScript können alle gewünschten Ziele erreicht werden.

Des Weiteren wurde die Verwendung einer Versionsverwaltungssoftware diskutiert. Da eine Versionsverwaltung viele Vorteile bietet, wie beispielsweise das Wiederherstellen von alten Zuständen des Projekts und die Protokollierung, wo jede Änderung an den Dateien mit Autor und Datum, also die ganze Versionsgeschichte, nachvollzogen werden kann, entschied man sich auch schnell und eindeutig für die Möglichkeit einer Versionsverwaltung. Außerdem ist es viel leichter, nachvollziehbarer und übersichtlicher als beispielsweise das Verschicken von einzelnen Codeteilen per E-Mail an die anderen Projektteilnehmer. Zudem bietet eine Versionsverwaltung noch die Möglichkeit Zugriffe und Entwicklungszweige zu koordinieren, was jedoch bei diesem Projekt aufgrund der Komplexität hinsichtlich der Projektteilnehmer nicht zwingend notwendig ist.\protect{\footnote{Skript des Kurses  Praxis des Programmierens: Versionsverwaltung Folien 29ff.}}
Als Versionsverwaltungssoftware einigte man sich schließlich auf den „GitHub Desktop“.  

Als Editor zur Erstellung von html- bzw. JavaScript-Code wurde einerseits unter Windows Notepad++ und andererseits für Mac OS die Software Brackets verwendet, da diese Open Source-Editoren sind und viele Sprachen, wie beispielsweise JavaScript, jQuery und HTML unterstützen. Sie genügen also allen im Projekt erwartenden Ansprüchen.
Bei der Entwicklung wurde vordergründig der Browser Google Chrome verwendet, da dieser alle verwendeten Sprachen, Frameworks und Methoden unterstützt. Darüber hinaus wurden auch die Browser Safari, Firefox und Opera für Tests miteinbezogen.

Ein weiteres Ziel ist eine fertige Desktop-App zu entwickeln. Dafür macht man sich die Software node.js in Verbindung mit dem Framework Electron zunutze. Der Vorteil hier ist, dass nach dem Erstellen des eigentlichen Programms mit dem Editor nur noch kleine Anpassungen vorgenommen werden müssen, um ein fertiges Programm zu erhalten. Dies hat die positive Auswirkung, dass der Nutzer nicht extra die verschiedenen HTML-Dateien abspeichern muss, womit er sich möglicherweise auch nicht sehr gut auskennt. Ein eigenständiges Programm erleichtert die Bedienbarkeit und die Nutzerfreundlichkeit. 

Darüber hinaus diskutierte man zu diesem frühen Stadium des Projektes bereits wie die abschließende Projektseminararbeit geschrieben werden soll. Betreuer Gerit Wagner empfahl die Verwendung des Softwarepaketes LaTex, das bei der Erstellung von größeren Abschlussarbeiten viele Vorteile gegenüber Microsoft Office Word bietet, abgesehen von dem Nachteil der Einarbeitungszeit in die neue Umgebung. Ein Argument ist, dass LaTex die Formatierung und den Inhalt voneinander trennt, indem man zu verändernde Textstellen mit Befehlen in einem Editor kennzeichnet, was ein sauberes und genau festlegbares Layout zur Folge hat.\protect{\footnote{\url{https://de.wikipedia.org/wiki/LaTeX}, abgerufen am 21.11.16}}  Außerdem gibt es seitens des Lehrstuhls bereits eine LaTex-Vorlage für Projektseminararbeiten auf die zurückgegriffen werden kann. Somit können die strengen Anforderungen für die Formatierung bzw. Gestaltung einer umfangreichen Projektseminarabschlussarbeit durch ein sauberes Layout erzielt werden. Zudem gibt es bereits grafische Editoren die den Umgang mit LaTex vereinfachen. Im Rahmen des Projekts wurde die Software TeXworks verwendet. Des Weiteren kann man LaTex-Dokumente mit Hilfe von Git versionieren und so wieder alle Vorteile einer Versionsverwaltung nutzen.


\section{Konzeptionelle Phase und Identifikation möglicher Probleme bzw. Schlüsselstellen
}
Dieser Unterpunkt soll einen Überblick über die allgemeine Vorgehensweise geben, die später noch detaillierter erläutert wird. Nach ersten Überlegungen mit welchen Mitteln das Projekt umgesetzt werden soll, folgten viele Gedanken über mögliche Schwierigkeiten bzw. die Herangehensweise bei der Erstellung des Zeitplan-Generators. Zuerst wurde natürlich das Ursprungsfile genauer betrachtet. Es wurde festgestellt, dass das Eingangsfile sehr viele irrelevante Daten beinhaltet und man jeweils nur die zwei Absätze über den Teilnehmerlisten benötigt. Parallel dazu verglich man die Zusammensetzung der Daten mit den dafür vorgesehenen Positionen in der Ergebnistabelle. Als Referenz für die Ergebnistabelle wurde wieder der Zeitplan der Sparkassen Gala 2016 verwendet. Es stellte sich heraus, dass die Aufschlüsselung der relevanten Daten eine Schwierigkeit werden könnte, da die Datensätze teilweise unterschiedliche Strukturen haben und die Informationen oft anhand mehrerer Suchkriterien identifiziert werden müssen. Des Weiteren wurde deutlich, dass die Befüllung der Tabelle eine Herausforderung werden kann, da die Wettkämpfe anhand des Datums, der Uhrzeit und der Teilnehmerklasse zugeordnet werden müssen. Bei der Umsetzung muss also ein besonderes Augenmerk auf die Identifikation der relevanten Daten und die saubere Befüllung der Ergebnistabelle gelegt werden. 

Ausgehend der gemeinsamen Überlegungen im Team wurden fünf größere Schritte für die Problemlösung bzw. Erstellung des Zeitplan-Generators definiert: Der erste Schritt ist die Spezifikation des Rohtextes. In diesem Prozess wird die genau Form des Eingangsfiles festgehalten, was insbesondere den Inhalt und die Struktur beinhaltet. Dabei ist es von besonderer Wichtigkeit zu erkennen an welchen Positionen die wesentlichen Daten, wie Datum, Uhrzeit, Teilnehmerklasse und Wettkampfbezeichnung stehen. Der darauffolgende Schritt ist das Einlesen des Ursprungsfiles. Um mit dem Rohtext zu arbeiten muss dieser natürlich zuerst vom Programm identifiziert und eingelesen werden. Hier ist es die Aufgabe des Nutzers das gewünschte File, das die zuvor spezifizierte Form aufweist, auszuwählen. Der dritte Schritt ist, dass man aus dem Ausgangsfile nur die relevanten Daten herausfiltert. Hier sollen praktisch nur noch alle relevanten Absätze angezeigt werden. Anschließend müssen diese Daten im vierten Schritt gesäubert werden. Das bedeutet, dass anhand bestimmter Suchkriterien das Datum, die Uhrzeit, die Teilnehmerklassen und die Wettkampfbezeichnung erkannt werden. Im letzten Schritt wird schließlich der gewünschte Zeitplan aus den zuvor identifizierten Informationen generiert. Für jeden Wettkampftag soll dabei eine eigene Tabelle erzeugt werden. Als Überschrift für eine Tabelle dient das Datum mit dem zugehörigen Wochentag. Der Beginn der Veranstaltung steht in der ersten Spalte unter dem Titel Zeit, wobei aufsteigend nach der Uhrzeit sortiert wird; die Altersklassen werden in der ersten Zeile ab der zweiten Zelle angeführt, wobei diese aszendierend und nach dem Geschlecht sortiert dargestellt werden und die Wettkampfbezeichnung wird schließlich in der richtigen Zelle ausgehend von Datum, Uhrzeit und Altersklasse eingetragen. 
Zusammenfassend werden also neben dem vorhandenen Eingangsfile vier HTML-Files erstellt, die der Problemlösung dienen. Dies hat den Vorteil der Modularität der unterschiedlichen Funktionen und des weiteren ist es bei der Programmierung leichter umzusetzen. Zudem ist eine gute Testbarkeit der Funktionalität bzw. einfacheres Debugging ermöglicht. Die genaue Vorgehensweise in den einzelnen Schritten wird nun im Folgenden genauer erläutert.

\section{Spezifikation des Rohtextes}
Die erste Anforderung an den Rohtext ist, dass dieser das Dateiformat HTML besitzen soll. Dies ermöglicht eine genaue Navigation mit Hilfe des \ac{DOM}. Im Folgenden wird nun der Inhalt und die Struktur des Eingangsfiles näher spezifiziert. Grundsätzlich kann der Rohtext beliebigen HTML-Code beinhalten mit der Ausnahme des im später erläuterten Aufbau eines Paragraphen. 
Das für die Entwicklung verwendete Ursprungsfile weist beispielsweise folgenden Aufbau auf. In den ersten zwei Zeilen des Files steht die Überschrift („Laufnacht und Sparkassen Gala 2016“) und der Ort bzw. das Datum („Regensburg, von 04.06.2016-05.06.2016“) geschrieben. Daraufhin folgen verschiedene Verweise, wie die Altersklassen (z.B. „Männer“ und „weibliche Jugend U20“) und alle Wettkampfbezeichnungen (z.B. „100m (Vorprogramm) - Zeitläufe“). Im Anschluss kommen die relevanten Zeilen für die Erstellung des Zeitplanes.
Im Testfile beispielsweise:
-	Zeile 1: „100m (Vorprogramm), Frauen + U20 + U18 – Zeitläufe“
-	Zeile 2: „Datum: 05.05.2016 Beginn: 12:00“
Diese zwei Zeilen sind DOM-Elemente der Form <p class=“ev1“>...</p>. Es handelt sich hier also um Paragraphen und man kann alle relevanten Daten mit Hilfe dieser Form identifizieren.
Der Paragraph ist im Allgemeinen also folgendermaßen aufgebaut:
Zeile 1 beinhaltet die Teilnehmerklassen (z.B. „Frauen + U20 + U18“) ungefähr in der Mitte der Zeile. im String gekennzeichnet folgt auf die ersten Zeichen und ein Komma (xxxx,) die Teilnehmerklasse. Auf die Teilnehmerklasse folgt ein Bindestrich und die nachfolgenden Zeichen (-xxxx). Die Teilnehmerklassen werden also initiiert durch ein Komma und beendet durch einen Bindestrich. Zudem enthalten alle Teilnehmerklassen die Zeichenfolgen „weiblich“, „weibliche“ oder „Frauen“ bzw. „männlich“, „männliche“ oder „Männer“. Außerdem ist es möglich, dass in diesem Abschnitt mehrere Teilnehmerklassen, abgetrennt durch ein „+“, enthalten sind. Auf das Pluszeichen würden dann ein „U“ und zwei Zahlen folgen. Ein weiterer Bestandteil der ersten Zeile ist gegebenenfalls der Inhalt der runden Klammern. Dort befinden sich Zusatzinformationen, die entfernt werden, wenn es sich um „Hauptprogramm“, „Gala“, „Vorprogramm“ oder „Laufnacht“ handeln sollte. Ansonsten bleibt der Inhalt der Klammern an dieser Stelle stehen. Es gibt aber auch den Fall, dass keine Zusatzinformationen in runden Klammern enthalten sind. Den Rest der Zeichenkette (nach Entfernung der Teilnehmerklasse und gegebenenfalls der Klammern) bildet die Disziplin. Die Disziplin setzt sich also aus den ersten Zeichen bis zur Klammer und den letzten Zeichen nach dem Bindestrich zusammen. Im Beispiel entsteht die Disziplin „100m Zeitläufe“.
Die zweite Zeile enthält das Datum und die Uhrzeit. Der erste Eintrag in der zweiten Zeile ist „Datum“ gefolgt vom Datum selbst in der Form dd.mm.yyyy. Der zweite Eintrag in der zweiten Zeile ist „Beginn“ gefolgt von der Uhrzeit des Wettkampfstarts mit dem vierundzwanzig Studenformat hh:mm.

Abgesehen davon kommt nach den Paragraphen im verwendeten Ausgangsfile immer eine Tabelle mit der Startnummer, dem Namen, dem Jahrgang, der Nationalität, dem Verein, der Saisonbestleistung und der persönlichen Bestleistung, sowie den verschiedenen Einträgen der Wettkampfteilnehmer. Dies ist jedoch für die Zeitplangenerierung nicht weiter relevant.

Zusammenfassend muss das Ausgangsfile also im HTML-Format vorliegen und DOM-Elemente mit der Form <p class= „ev1“>...</p> enthalten, die als Inhalt die relevanten Daten haben. Zudem müssen die Paragraphen den wie oben beschriebenen Aufbau aufweisen, damit alle Daten im Anschluss richtig verarbeitet werden können. 
Nachdem der Rohtext genauer spezifiziert wurde, wird die Funktionsweise des File-Uploaders im Folgenden genauer erklärt.

\section{Funktionalität des File-Uploaders}
Nachdem das Inputfile genauer spezifiziert wurde, wird nun die Funktionsweise des File-Uploaders näher erklärt. Die Vorbedingung für den File-Uploader ist, dass der Rohtext in der zuvor definierten Form vorliegt.

 Im ersten Schritt wird nun der HTML-Code erstellt. Dieser setzt sich aus dem HTML-Kopf (HEAD) und dem HTML-Körper (BODY) zusammen, die jeweils auch durch die gleichnamigen Tags eingeleitet und beendet werden. Im HEAD werden lediglich Informationen des Web-Dokuments wie in diesem Falle der Titel und der zu verwendende Zeichensatz \ac{UTF-8} als Metainformation definiert. Die Verwendung von UTF-8 als Zeichensatz hat den Vorteil, dass alle Zeichen (auch Fremdwörter und Sonderzeichen) beliebig verwendet werden können.\protect{\footnote{\url{https://wiki.selfhtml.org/wiki/Zeichenkodierung}, aberufen am 23.11.16}} Des weiteren ist UTF-8 beispielsweise von der \ac{IETF} und der \ac{ISO} als Norm definiert worden, was die Nutzung rechtfertigt.\protect{\footnote{\url{https://de.wikipedia.org/wiki/UTF-8}, abgerufen am 23.11.16}}  Im BODY wurde der Nutzerhinweis „Read in the rawTable!“  und der Inputtyp festgelegt. Dabei wurde bestimmt, dass der Input vom Typ eines Files sein soll. Dies wurde mit dem div-Element definiert, was ermöglicht, dass die Inhalte des Files sauber in einen Bereich dargestellt werden. Außerdem wurde die Möglichkeit für den Nutzer das File mit Hilfe eines Formulars auszuwählen integriert (form-Tag). Formulare in HTML dienen der Eingabe von Informationen durch den Benutzer. Die Benutzereingaben werden beim Absenden des Formulars an die im action-Attribut spezifizierte Adresse (ParagraphHandler.html) geschickt. Dabei werden die Daten erst versendet, wenn diese mit dem Formular-Element Submit-Button bestätigt wurden. (Nach Debugging/Programmierung auskommentieren des Buttons und automatische Weiterleitung). Zudem wurde im HTML-Körper noch die Bildschirmausgabe (displayArea) deklariert, die eventuelle Ausgaben anzeigt. 

Im JavaScript-Code wurden die restlichen Funktionalitäten des File-Uploaders festgelegt. JavaScript ist eine Skriptsprache, die HTML um Funktionalitäten erweitert und dynamische Informationen im Web realisiert. Das Skript wird in HTML-Dokumente mit dem script-Tag eingebettet. Dies ermöglicht beispielsweise, dass Benutzerinteraktionen ausgewertet bzw. Inhalte erzeugt oder verändert werden können. Diese Eigenschaften werden hier benötigt. Es wurden zuerst Variablen definiert, die die relevanten DOM-Elemente „fileInput“ und „displayArea“ abspeichern, um diese im JavaScript-Code verändern zu können bzw. um auf diese zugreifen zu können. Im Folgenden wurde der User-Input als Event definiert. Dies ermöglicht, dass man auf eine Fileauswahl des Nutzers im Select-Auswahlmenü reagieren kann. Hat der Nutzer also eine Auswahl getroffen bzw. liegt eine Veränderung beim Inputfile vor (change), wird das Event ausgelöst. Bei der Auslösung des Events müssen zunächst die Bedingungen zur Ausführung des JavaScript-Codes festgelegt werden. Der Code arbeitet mit dem zuerst ausgewählten File (erste Stelle im Array) und prüft anschließend, ob das File den zuvor definierte Typ HTML aufweist. Wird an dieser Stelle erkannt, dass ein anderes Format vorliegt, wird das Event abgebrochen und es wird dem Nutzer eine Fehlermeldung („File not supported!“) im displayArea ausgegeben. Handelt es sich um ein HTML-File, ermöglicht die File Reader-\ac{API} das Auslesen des Textes. Um einen korrekten deutschen Text als Ergebnis zu erhalten, muss das File nach ISO-8859-1 enkodiert werden. Dies vermeidet beispielsweise, dass im Web-Dokument Umlaute nicht richtig dargestellt werden können. Sobald das File fertig geladen ist, wird der Inhalt des Eingangsfiles in der Variable „rawText“ gespeichert. Hier macht man sich die Methoden onload und result der File Reader-API zunutze. Onload erkennt, wann das File komplett eingelesen wurde und result gibt den Inhalt des Files zurück.\protect{\footnote{\url{https://www.w3.org/TR/FileAPI/}, abgerufen am 24.11.19}} Darüber hinaus soll das Ergebnis des Einlesens, also die zuvor definierte Variable rawText, im sessionStorage abgespeichert werden. Die Datenspeicherung wird also an die aktuelle Browsersession gebunden, d.h. die Daten bleiben deshalb auch nur so lange gespeichert bis die Sitzung geschlossen wurde. Nachdem dies geschehen ist wird der Text aus dem sessionStorage angezeigt. Diese beiden Funktionalitäten wurden in den Methoden showText(area) bzw. saveRawText(rawText) ausgelagert. 

 Nach dem Abschluss der Programmierphase bzw. des Testens wurde der Submit-Button und die Anzeige des eingelesenen und abgespeicherten Files im Code auskommentiert bzw. auf versteckt (hidden) gesetzt. Dies hat den Vorteil, dass man bei der Ausführung des kompletten Codes zur Erstellung der Tabelle durch das automatische Weiterleiten zum ParagraphHandler Zeit spart. Zudem ist es für den Nutzer irrelevant, dass er das eingelesene File mit den unstrukturierten Daten angezeigt bekommt. Bei Bedarf kann das Auskommentieren natürlich wieder rückgängig gemacht werden, was das Debugging bzw. die Erweiterung des Tools vereinfachen würde. 

Ist also der Rohtext (rawText) im sessionStorage, leitet das Programm automatisch (Auto-Submit) zum nächsten Schritt bei der Generierung einer Tabelle, dem ParagraphHandler, weiter. Beim Prozess der Erstellung der Ergebnistabelle wird im Folgenden die Funktionsweise des ParagraphHandlers detaillierter erklärt.



\section{Beispiele}
Dies  ist eine Referenz auf ein Paper \cite{Kolter2009}. Die Verwaltung der Referenzen erfolgt in der Datei References.bib. Zur Bearbeitung der Referenzen kann beispielsweise das Programm JabRef\protect{\footnote{\url{http://jabref.sourceforge.net/}}} verwendet werden.



Referenze auf Grafiken: \ref{fig:Fig1}, \ref{img:subFig2}, \ref{img:subFigs}

\begin{figure}
  \centering
  \includegraphics[width=0.95\textwidth]{Fig1.pdf}
  \caption{Beispielgrafik}
  \label{fig:Fig1}
\end{figure}


\begin{figure}
  \centering
  \subfigure[subfigure 1 \label{img:subFig1}]{\fbox{\includegraphics[width=0.45\textwidth]{Fig.png}}}\hfill
  \subfigure[subfigure 2\label{img:subFig2}]{\fbox{\includegraphics[width=0.45\textwidth]{Fig2.pdf}}}\hfill
  \caption{Beispiel subfigure}
  \label{img:subFigs}
\end{figure}



\lstset{language=JAVA, breaklines=true, tabsize=2}
\lstinputlisting[caption=HelloWorld,
label=lst:HelloWorld]{listings/HelloWorld.java}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
